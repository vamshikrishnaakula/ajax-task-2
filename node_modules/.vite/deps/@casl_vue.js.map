{
  "version": 3,
  "sources": ["../../@casl/vue/src/reactiveAbility.ts", "../../@casl/vue/src/useAbility.ts", "../../@casl/vue/src/component/can.ts", "../../@casl/vue/src/plugin.ts"],
  "sourcesContent": ["import { AnyAbility, SubjectType } from '@casl/ability';\nimport { ref } from 'vue';\n\nexport function reactiveAbility(ability: AnyAbility) {\n  if (ability.hasOwnProperty('possibleRulesFor')) {\n    return ability;\n  }\n\n  const watcher = ref(true);\n  ability.on('updated', () => {\n    watcher.value = !watcher.value;\n  });\n\n  const possibleRulesFor = ability.possibleRulesFor.bind(ability);\n  ability.possibleRulesFor = (action: string, subject: SubjectType) => {\n    watcher.value = watcher.value; // eslint-disable-line\n    return possibleRulesFor(action, subject);\n  };\n  ability.can = ability.can.bind(ability);\n  ability.cannot = ability.cannot.bind(ability);\n\n  return ability;\n}\n", "import { inject, InjectionKey, provide } from 'vue';\nimport type { AnyAbility, Ability } from '@casl/ability';\nimport { reactiveAbility } from './reactiveAbility';\n\nexport const ABILITY_TOKEN: InjectionKey<Ability> = Symbol('ability');\n\nexport function useAbility<T extends AnyAbility = Ability>(): T {\n  const ability = inject<T>(ABILITY_TOKEN);\n\n  if (!ability) {\n    throw new Error('Cannot inject Ability instance because it was not provided');\n  }\n\n  return ability;\n}\n\nexport function provideAbility(ability: AnyAbility) {\n  provide(ABILITY_TOKEN, reactiveAbility(ability));\n}\n", "import { defineComponent, ComponentCustomProperties } from 'vue';\nimport {\n  SubjectType,\n  Generics,\n  AnyAbility,\n  Ability,\n  Abilities,\n  IfString,\n  AbilityTuple,\n} from '@casl/ability';\nimport { useAbility } from '../useAbility';\n\ntype AbilityCanProps<\n  T extends Abilities,\n  Else = IfString<T, { do: T } | { I: T }>\n> = T extends AbilityTuple\n  ? { do: T[0], on: T[1], field?: string } |\n  { I: T[0], a: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], an: Extract<T[1], SubjectType>, field?: string } |\n  { I: T[0], this: Exclude<T[1], SubjectType>, field?: string }\n  : Else;\n\nexport type CanProps<T extends AnyAbility> = AbilityCanProps<Generics<T>['abilities']> & {\n  not?: boolean,\n  passThrough?: boolean\n};\n\ntype VueAbility = ComponentCustomProperties extends { $ability: AnyAbility }\n  ? ComponentCustomProperties['$ability']\n  : Ability;\n\nfunction detectSubjectProp(props: Record<string, unknown>) {\n  if ('a' in props) {\n    return 'a';\n  }\n\n  if ('this' in props) {\n    return 'this';\n  }\n\n  if ('an' in props) {\n    return 'an';\n  }\n\n  return '';\n}\n\nexport const Can = defineComponent<CanProps<VueAbility>>({\n  name: 'Can',\n  props: {\n    I: String,\n    do: String,\n    a: [String, Function],\n    an: [String, Function],\n    this: [String, Function, Object],\n    on: [String, Function, Object],\n    not: Boolean,\n    passThrough: Boolean,\n    field: String\n  } as any,\n  setup(props, { slots }) {\n    const $props = props as Record<string, any>;\n    let actionProp = 'do';\n    let subjectProp = 'on';\n\n    if (!(actionProp in props)) {\n      actionProp = 'I';\n      subjectProp = detectSubjectProp(props);\n    }\n\n    if (!$props[actionProp]) {\n      throw new Error('Neither `I` nor `do` prop was passed in <Can>');\n    }\n\n    if (!slots.default) {\n      throw new Error('Expects to receive default slot');\n    }\n\n    const ability = useAbility<VueAbility>();\n\n    return () => {\n      const isAllowed = ability.can($props[actionProp], $props[subjectProp], $props.field);\n      const canRender = props.not ? !isAllowed : isAllowed;\n\n      if (!props.passThrough) {\n        return canRender ? slots.default!() : null;\n      }\n\n      return slots.default!({\n        allowed: canRender,\n        ability,\n      });\n    };\n  }\n});\n", "import { App } from 'vue';\nimport { AnyAbility, PureAbility } from '@casl/ability';\nimport { ABILITY_TOKEN } from './useAbility';\nimport { reactiveAbility } from './reactiveAbility';\n\nexport interface AbilityPluginOptions {\n  useGlobalProperties?: boolean\n}\n\nexport function abilitiesPlugin(app: App, ability: AnyAbility, options?: AbilityPluginOptions) {\n  if (!ability || !(ability instanceof PureAbility)) {\n    throw new Error('Please provide an Ability instance to abilitiesPlugin plugin');\n  }\n\n  app.provide(ABILITY_TOKEN, reactiveAbility(ability));\n\n  if (options && options.useGlobalProperties) {\n    app.config.globalProperties.$ability = ability;\n    app.config.globalProperties.$can = ability.can.bind(ability);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;AAGO,SAASA,gBAAgBC,GAAAA;AAAAA,MAC1BA,EAAQC,eAAe,kBAAA;AAAA,WAClBD;AAAAA,QAGHE,IAAUC,IAAI,IAAA;AACpBH,IAAQI,GAAG,WAAW,MAAA;AACpBF,MAAQG,QAAAA,CAASH,EAAQG;EAAAA,CAAAA;AAAAA,QAGrBC,IAAmBN,EAAQM,iBAAiBC,KAAKP,CAAAA;AACvDA,IAAQM,mBAAmB,CAACE,GAAgBC,OAAAA;AAC1CP,MAAQG,QAAQH,EAAQG;AAAAA,WACjBC,EAAiBE,GAAQC,EAAAA;EAAAA;AAElCT,IAAQU,MAAMV,EAAQU,IAAIH,KAAKP,CAAAA;AAC/BA,IAAQW,SAASX,EAAQW,OAAOJ,KAAKP,CAAAA;AAAAA,SAE9BA;AAAAA;AAAAA,ICjBIY,IAAuCC,OAAO,SAAA;AAEpD,SAASC,aAAAA;AAAAA,QACRd,IAAUe,OAAUH,CAAAA;AAAAA,MAAAA,CAErBZ;AAAAA,UACG,IAAIgB,MAAM,4DAAA;AAAA,SAGXhB;AAAAA;AAGF,SAASiB,eAAejB,GAAAA;AAC7BkB,UAAQN,GAAeb,gBAAgBC,CAAAA,CAAAA;AAAAA;ACczC,SAASmB,EAAkBC,GAAAA;AAAAA,MACrB,OAAOA;AAAAA,WACF;AAAA,MAGL,UAAUA;AAAAA,WACL;AAAA,MAGL,QAAQA;AAAAA,WACH;AAAA,SAGF;AAAA;AAAA,IAGIC,IAAMC,gBAAsC,EACvDC,MAAM,OACNH,OAAO,EACLI,GAAGC,QACHC,IAAID,QACJE,GAAG,CAACF,QAAQG,QAAAA,GACZC,IAAI,CAACJ,QAAQG,QAAAA,GACbE,MAAM,CAACL,QAAQG,UAAUG,MAAAA,GACzB3B,IAAI,CAACqB,QAAQG,UAAUG,MAAAA,GACvBC,KAAKC,SACLC,aAAaD,SACbE,OAAOV,OAAAA,GAETW,MAAMhB,GAAAA,EAAOiB,OAAEA,EAAAA,GAAAA;AAAAA,QACPC,IAASlB;AAAAA,MACXmB,IAAa;AAAA,MACbC,IAAc;AAAA,MAAA,EAEZD,KAAcnB,IAAQ;AAC1BmB,QAAa;AACbC,QAAcrB,EAAkBC,CAAAA;EAAAA;AAAAA,MAAAA,CAG7BkB,EAAOC,CAAAA;AAAAA,UACJ,IAAIvB,MAAM,+CAAA;AAAA,MAAA,CAGbqB,EAAMI;AAAAA,UACH,IAAIzB,MAAM,iCAAA;AAAA,QAGZhB,KAAUc,WAAAA;AAAAA,SAET,MAAA;AAAA,UACC4B,KAAY1C,GAAQU,IAAI4B,EAAOC,CAAAA,GAAaD,EAAOE,CAAAA,GAAcF,EAAOH,KAAAA;AAAAA,UACxEQ,KAAYvB,EAAMY,MAAAA,CAAOU,KAAYA;AAAAA,QAAAA,CAEtCtB,EAAMc;AAAAA,aACFS,KAAYN,EAAMI,QAAAA,IAAa;AAAA,WAGjCJ,EAAMI,QAAS,EACpBG,SAASD,IACT3C,SAAAA,GAAAA,CAAAA;EAAAA;AAAAA,EAAAA,CAAAA;ACjFD,SAAS6C,EAAgBC,GAAU9C,GAAqB+C,GAAAA;AAAAA,MAAAA,CACxD/C,KAAAA,EAAaA,aAAmBgD;AAAAA,UAC7B,IAAIhC,MAAM,8DAAA;AAGlB8B,IAAI5B,QAAQN,GAAeb,gBAAgBC,CAAAA,CAAAA;AAAAA,MAEvC+C,KAAWA,EAAQE,qBAAqB;AAC1CH,MAAII,OAAOC,iBAAiBC,WAAWpD;AACvC8C,MAAII,OAAOC,iBAAiBE,OAAOrD,EAAQU,IAAIH,KAAKP,CAAAA;EAAAA;AAAAA;",
  "names": ["reactiveAbility", "ability", "hasOwnProperty", "watcher", "ref", "on", "value", "possibleRulesFor", "bind", "action", "subject", "can", "cannot", "ABILITY_TOKEN", "Symbol", "useAbility", "inject", "Error", "provideAbility", "provide", "detectSubjectProp", "props", "Can", "defineComponent", "name", "I", "String", "do", "a", "Function", "an", "this", "Object", "not", "Boolean", "passThrough", "field", "setup", "slots", "$props", "actionProp", "subjectProp", "default", "isAllowed", "canRender", "allowed", "abilitiesPlugin", "app", "options", "PureAbility", "useGlobalProperties", "config", "globalProperties", "$ability", "$can"]
}
